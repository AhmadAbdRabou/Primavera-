#'ProjectData.py'

# Loading built-in packages
import sys
import os
import os.path
from os.path import dirname, join
import base64
import time
import mimetypes
# Loading Bokeh packages
from bokeh.layouts import widgetbox
from bokeh.models.widgets import Div, FileInput, TextAreaInput, Button, Panel, Tabs
from bokeh.models.widgets import DataTable, TableColumn
from bokeh.models import ColumnDataSource
# Loading Pandas packages
import pandas as pd
# Loading jinja2 packages
from jinja2 import Template
# Loading application modules
from .primaveraplus import loadschema, readxer

class projectdata:
    ''' ProjectData class is the core function of '/ProjectData' application page
     ProjectData receives 'doc' argument from the caller init module which is generated by Bokeh Application
     ProjectData is responsible of creating the controls which is displayed on the application page, initiate the controls, and response according to user events
     ProjectData provides the following functionalities:
           Upload XER file from user environment
           Display XER file contents on the display screen
           Save XER file to disegnated folder on server
           Covert XER file to Excel-book
           Display some of Excel-book tables on panel tabs
           Provide a download link of the Excel-book
           Inform the user of the work being currently done through the display screen'''

    # Initiating class
    # 'doc' is generated by the caller (Bokeh Application)
    def __init__(self, doc):
        ###############     Initiating Variables     ###################
        self.doc = doc
        self.uploaded_projects_path = join(dirname(__file__),"..","data","uploaded_projects")
        self.extracted_projects_path = join(dirname(__file__),"..","data","extracted_projects")
        self.current_uploaded_file = "No file loaded"
        self.current_extracted_file = "No Project"
        self.full_uploaded_project_path = "empty"
        self.full_extracted_project_path = "empty"
        self.download_file_path = "No file to download"
        self.tables = []

        ###############     Creating Controls        ###################
        #self.fileinput = FileInput(accept=".xer", name="fileinput", css_classes=["myinput"])
        self.fileinput = FileInput(accept=".xer", name="fileinput", css_classes=["myinput"])
        self.textarea = TextAreaInput(value="XER file contents will show here!", rows = 10, name="textarea", css_classes=["mytext"])
        self.extract = Button(label="Extract Data", name="extract", css_classes=["mybutton"])
        self.download = Div(text="""No file to download""", name="download", css_classes=["mylink"])
        self.panel_tabs = self.init_panels()

        ###############     Defining Responses        ###################
        self.fileinput.on_change('value', self.upload_init)
        self.extract.on_click(self.extract_init)

        ###############     Exporting Controls        ###################
        self.doc.add_root(self.fileinput)
        self.doc.add_root(self.textarea)
        self.doc.add_root(self.extract)
        self.doc.add_root(self.download)
        self.doc.add_root(self.panel_tabs)
        
    def init_panels(self):
        # Load Primavera partial schema
        schema = loadschema.loadschema()
        # Create list of empty Bokeh DataTables
        self.tables = self.initiate_data_tables(schema)
        # Initiate list of tabs
        datatables = []
        # For each Bokeh DataTable....
        for index, table in enumerate(self.tables):
            # Assign Bokeh DataTable to new tab
            tab = Panel(child=table, title=table.name)
            # Append tab to list of tabs
            datatables.append(tab)
        # Create the panel of tabs and return. CSS Class name 'mypanel' will be used by the styling sheet
        return Tabs(tabs=datatables, name="panel", css_classes=["mypanel"])

    # 'schema' is generated by loadschema
    def initiate_data_tables(self, schema):
        # Initiate return container
        tables = []
        # for each Dictionary in the schema
        for dic in schema:
            # Initiate a new List for Bokeh TableColumn object which represent a table column
            table_columns = []
            # Initiate an empty data source (Dictionary) for the table, to be updated when the actual project is loaded
            table_source = {}  
            # for each column name in the columns' names list
            for column in list(dic.values())[0]:
                # Create a new Bokeh TableColumn object and append to column's list
                table_columns.append(TableColumn(field=column, title=column))
                # Create Dictionary entry for each column, where key = column's name, and value = list of empty values
                table_source[column] = [' ']*15
            # Use empty data source dictionary to create Bokeh ColumnDataSource which is the data source for Bokeh DataTable
            source = ColumnDataSource(data=table_source)
            # Create Bokeh DataTable with Bokeh ColumnDataSource and Bokeh TableColumn objects, table name = key of schema dictionary
            # CSS Class name 'mytable' will be used by the styling sheet since the table will be rendered with the assigned class name
            datatable = DataTable(source = source, columns = table_columns, width=780, fit_columns = False, name=list(dic.keys())[0], css_classes=["mytable"], reorderable=False)
            # Append the DataTable to the return container
            tables.append(datatable)
        # Return
        return tables 

    def update_data_tables(self):
        # Prepare the Excel-book file name to open
        file_name = str(self.current_uploaded_file).split(sep='xer')[0] + 'xlsx'
        # Generate on server full path to the Excel-book
        project = join(self.extracted_projects_path, file_name)
        # open Excel-book
        with pd.ExcelFile(project) as xl:
            # Access each sheet in the Excel-book
            for index, sheet in enumerate(xl.sheet_names):
                # Load the sheet into Pandas DataFrame
                data = xl.parse(sheet)
                # Create data source
                source = ColumnDataSource(data.head(15))
                # Access each Bokeh DataTable
                for table in self.tables:
                    # If DataTable name matches current Excel-book sheet...
                    if table.name==sheet:
                        # Update DataTable source 
                        table.source = source

    def upload_init(self, attr, old, new):
        # Because Bokeh state only synchronizes with the browser when the callback ends
        # Uploading has to be divided to steps using add_next_tick_callback(step) and time.sleep
        # Uploading uses 'upload_core' and 'upload_finalize' functions

        # Assign current project to uploaded file
        self.current_uploaded_file = self.fileinput.filename
        # Initiate file types
        mimetypes.init()
        # Check for uploaded file type
        file_type, file_encoding = mimetypes.guess_type(self.current_uploaded_file, strict=False)
        # If the file is not XER file
        if file_type == 'application/xer':
            # Assign full path for uploaded file
            self.full_uploaded_project_path = join(self.uploaded_projects_path, self.current_uploaded_file)
            # Clear previous messages and Inform user about the start of uploading process
            self.textarea.value = "\n" + "Uploading..." + "\n"
            # Execute uploading on next server cycle
            self.doc.add_next_tick_callback(self.upload_core)
        else:
            # Warn the user and do nothing
            self.textarea.value = "\n" + "Please select XER file to upload" + "\n"

    def upload_core(self):
        # Postpond the execution a little bit
        time.sleep(0.1)        
        # Upload file and decode the contents into bytes
        file_contents = base64.b64decode(self.fileinput.value)
        # Decode the uploaded bytes to ANSI text
        self._string_file = file_contents.decode("ANSI")
        # Inform user with file contents
        self.textarea.value =  "\n" + self._string_file + "\n" + self.textarea.value
        # Execute saving on next server cycle
        self.doc.add_next_tick_callback(self.upload_finalize)
        # Inform user that file is being saved
        self.textarea.value =  "\n" + "Saving ..." + "\n" + self.textarea.value
        
    def upload_finalize(self):
        # Postpond the execution a little bit
        time.sleep(0.1) 
        # Create text file at server
        with open(self.full_uploaded_project_path,"w") as save_file:
            # Save loaded file on server
            save_file.write(self._string_file)
        # Inform user that uploading is finished
        self.textarea.value =  "\n" + "Uploading Finished" + "\n" + self.textarea.value

    def extract_init(self):
        # Because Bokeh state only synchronizes with the browser when the callback ends
        # Extraction has to be divided to steps using add_next_tick_callback(step) and time.sleep
        # Extraction uses 'extract_core' and 'extract_finalize' functions
        
        # Check if XER file exists on server
        if os.path.isfile(self.full_uploaded_project_path):
            # Clear previous messages and Inform user about the start of extractig process
            self.textarea.value = "\n" + "Extracting..." + "\n"
            # Execute extraction on next server cycle
            self.doc.add_next_tick_callback(self.extract_core)
        else:
            # Inform the user and do nothing
            self.textarea.value = "\n" + "Please upload XER file before extracting" + "\n"

    def extract_core(self):
        # Postpond the execution a little bit
        time.sleep(0.1)
        # Assign extracted porject
        self.current_extracted_file = self.current_uploaded_file.split(sep=".xer")[0]+".xlsx"
        self.full_extracted_project_path = join(self.extracted_projects_path, self.current_extracted_file)
        # Extract XER file tables and save it to Excel-book, validate the extracted file
        status = readxer.readxer(self.current_uploaded_file,self.uploaded_projects_path,self.extracted_projects_path)
        # If sucess, continue
        if status=="sucess":
            # Inform user about progress
            self.textarea.value = "\n" + "Loading Tables..." + "\n" + self.textarea.value
            # Execute viewing extracted data on next server cycle
            self.doc.add_next_tick_callback(self.extract_finalize)
        # If empty project, inform the user and do nothing
        elif status=="No_Activities":
            self.textarea.value = "\n" + "This project has no activities" + "\n" + self.textarea.value
            self.reset_porject()

        # If no project, inform the user and do nothing
        elif status=="No_Project":
            self.textarea.value = "\n" + "There is no project to load" + "\n" + self.textarea.value
            self.reset_porject()

    def extract_finalize(self):
        # Postpond the execution a little bit
        time.sleep(0.1)
        # Update Bokeh DataTables
        self.update_data_tables()
        # Inform user about progress
        self.textarea.value = "\n" + "Loading Tables Finished" + "\n" + self.textarea.value
        # Prepare download link href
        self.download_file_path = "/data/extracted_projects/"+self.current_extracted_file
        # Prepare download link display text (file name)
        download_file = self.current_extracted_file
        # Generate download link
        self.download.text = """<a href="""+'"'+self.download_file_path+'" '+"""download>"""+download_file+"""</a>"""
        # Inform user that download is available
        self.textarea.value = "\n" + download_file + " is available to download" + "\n" + self.textarea.value

    def reset_porject(self):
        os.remove(self.full_extracted_project_path)
        os.remove(self.full_uploaded_project_path)
        self.current_uploaded_file = "No file loaded"
        self.current_extracted_file = "No Project"
        self.full_uploaded_project_path = "empty"
        self.full_extracted_project_path = "empty"
        
        


# the argument doc is generated by the caller (Bokeh Application)
def init(doc):
    ''' init is used by Bokeh FunctionHandler and Bokeh Application to generate application page
     init receives the argument 'doc' which is automatically generated by Bokeh Application
     init assign HTML template to the doc using Jinja2 Template
     init also assign Bokeh objects, which is the core functionality, to the doc using 'projectdata' calss from ProjectData module
     init returns the loaded doc to the server'''
    # Open HTML template file as t
    with open(join(dirname(__file__),"..","templates","ProjectData.html")) as t:
        # Assign the template to doc template
        doc.template = Template(t.read())
    # Assign Bokeh object to the doc
    projectdatadoc = projectdata(doc)
    # Return doc to server
    return projectdatadoc.doc





